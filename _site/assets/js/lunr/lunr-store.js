var store = [{
        "title": "ABC323 풀이 및 후기",
        "excerpt":"   ABC323    [후기]     영광스러운 블로그의 첫 게시물이다. 고3이 수능이 40일도 남지 않은 시점에서 블로그를 만들고 Atcoder에 참가하고 후기까지 쓰고 있다. 최대한 자제하고는 싶었지만, 오늘 친 실모가 점수가 잘 떴다는 변명 하나로 합리화하면서 좀 놀았다.   Atcoder에 참가한 경험이 많지는 않지만, Atcoder problems를 심심할 때마다 풀어본 경험으로 미루어 보았을 때, 전체적으로 쉬웠던 편이라고 느꼈다.   사실, 다른 문제들에 비해 쉽다고 느꼈을 뿐이지 그렇다고 해서 드라마틱하게 많이 풀거나 그러진 못했다.      A, B를 10분 안에 풀어서 이때까지만 해도 느낌이 좋았지만, C에서 wrong이 떠서 30분 넘게 시간을 허비하면서 D는 볼 힘도 남아있지 않았었다.    D는 대회 이후 업솔빙 했다.   [풀이]   A - Weak Beats (2:14)      Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 100 points     Problem Statement  You are given a string S of length 16 consisting of 0 and 1. If the i-th character of S is 0 for every even number i from 2 through 16, print Yes; otherwise, print No.     Constraints  (S is a string of length 16 consisting of 0 and 1.)    0과 1로 이루어진 16자리의 문자열이 주어진다. 이때, 짝수 번째에 위치한 숫자가 모두 0이면 Yes을 출력, 아니면 No을 출력하는 문제다.   import sys input = sys.stdin.readline  num = input()  for i in range(1,17):     if i%2 == 0:         if num[i-1] == '1':             print('No')             sys.exit(0)  print('Yes')  풀이 코드  사실 엄청 쉬운 문제인데 영어라서 시간이 걸렸다. 영어 속독 연습해야 할 듯…   B - Round-Robin Tournament (6:54)      Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 200 points     Problem Statement  There are N players numbered 1 to N, who have played a round-robin tournament. For every match in this tournament, one player won and the other lost. The results of the matches are given as N strings $S_{1}​,S_{2}​,…,S_{N}​$ of length N each, in the following format:                 If i != j, the j-th character of $S_{i}$ is o or x. o means that player i won against player j, and x means that player i lost to player j.                  If i=j, the j-th character of $S_{i}$​ is -.             The player with more wins ranks higher. If two players have the same number of wins, the player with the smaller player number ranks higher. Report the player numbers of the N players in descending order of rank.     Constraints  2≤N≤100  N is an integer.  Si​ is a string of length  N consisting of o, x, and -.  $S_{1}​,…,S_{N}$​ conform to the format described in the problem statement.    o 의 개수를 점수로 생각하고, 점수와 동시에 N을 저장한다. 이후, N에 대해서 오름차순으로 정리하고, 점수에 대해 내림차순으로 정렬한다.   import sys input = sys.stdin.readline  n = int(input()) lst = [] ans = []  for _ in range(n):     lst.append((input().count('o'), _+1))  lst.sort(key=lambda x:x[1]) lst.sort(key=lambda x:x[0], reverse=True)  for _, i in lst:     print(i, end=' ')  풀이 코드  sort를 어떻게 해야 할지 까먹었었다. sort()의 key를 사용해서 특정 부분에 따라 정렬할 수 있다.   C - World Tour Finals (41:31)     Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 250 points     Problem Statement  The programming contest World Tour Finals is underway, where N players are participating, and half of the competition time has passed. There are M problems in this contest, and the score $A_{i}$​ of problem i is a multiple of 100 between 500 and 2500, inclusive.     For each i=1,…,N, you are given a string Si​ that indicates which problems player i has already solved. $S_{i}$​ is a string of length M consisting of o and x, where the j-th character of Si​ is o if player i has already solved problem j, and x if they have not yet solved it. Here, none of the players have solved all the problems yet.     The total score of player i is calculated as the sum of the scores of the problems they have solved, plus a bonus score of i points.     For each i=1,…,N, answer the following question.          At least how many of the problems that player i has not yet solved must player i solve to exceed all other players’ current total scores?       Note that under the conditions in this statement and the constraints, it can be proved that player i can exceed all other players’ current total scores by solving all the problems, so the answer is always defined.     Constraints  2≤N≤100  1≤M≤100  500≤$A_{i}$​≤2500  $A_{i}$​ is a multiple of 100.  $S_{i}$​ is a string of length  M consisting of o and x.  $S_{i}$​ contains at least one x.  All numeric values in the input are integers.    문제 한번 더럽게 길다. 솔직히 30분 중에 이해하는데 10분 넘게 쓴 거 같다. 게다가 처음 넣은 답은 접근 자체는 맞았지만 ‘이미 푼 문제’를 고려하지 않아서 틀려버렸다. 이거 생각해 내는데 꽤 걸렸었다. 이후 ‘풀지 않은 문제들(풀 수 있는 문제들)’을 none_solve 리스트에 저장해서 해결했다.   import sys from collections import deque input = sys.stdin.readline  n,m = map(int,input().split()) score = list(map(int,input().split())) current = [] part_score = [] none_solve = list([] for x in range(n))   for _ in range(n):     current.append(list(input().strip()))  for i in range(n):     a = 0     for j in range(m):         if current[i][j] == 'o':             a += score[j]         else:             none_solve[i].append(score[j])     part_score.append(a+i+1)  for i in range(n):     a = part_score[i]     ans = 0     while a &lt; max(part_score):         a += sorted(none_solve[i], reverse=True)[ans]         ans += 1     print(ans)  풀이 코드  제출한 오답  고작 이 정도 구현으로 힘들어하다니 백준 실랜디 좀 열심히 해야 할 것 같다.   [업솔빙]   D - Merge Slimes      Time Limit: 3 sec / Memory Limit: 1024 MB  Score :425 points     Problem Statement  Initially, there are N sizes of slimes. Specifically, for each 1≤i≤N, there are $C_{i}$​ slimes of size $S_{i}$​.     Takahashi can repeat slime synthesis any number of times (possibly zero) in any order. Slime synthesis is performed as follows.          Choose two slimes of the same size. Let this size be X, and a new slime of size 2X appears. Then, the two original slimes disappear.       Takahashi wants to minimize the number of slimes. What is the minimum number of slimes he can end up with by an optimal sequence of syntheses?     Constraints  $1≤N≤10^{5}$  $1≤S_{i}​≤10^9$  $1≤C_{i}​≤10^9$  $S_{1}​,S_{2}​,…,S_{N}$​ are all different.  All input values are integers.    문제를 보고 바로 생각난 것은 2048 game이었다. 그다음으로 생각난 건 ‘도대체 어떻게 풀지’였다.   처음에는 주어진 횟수만큼 반복을 돌아서 모든 슬라임들이 존재하는 리스트를 만들고, 이후에 차례대로 슬라임을 합쳐주는 함수를 정의해서 재귀적으로 해결하려고 하였다. 그러나 $S_{i}$와 $C_{i}$ 가 각각 $10^9$까지 가능하였기에 입력에서만 $O(n^{2})$의 복잡도를 가지는 해당 방법은 사용할 수가 없었다. 그래서 시간을 봤는데, 3초 시간제한에 메모리는 1024 MB이길레 사실 이때 그냥 포기하고 GIST 면접 준비했다. 대회가 끝난 이후, 다시 문제를 보면서 mod(%) 연산과 Floor division(//) 연산을 사용해서 어떻게 줄일 수 있지 않을까 싶었는데, 더 생각하기 귀찮아져서 바로 Editorial을 깠다.   그런데 Editorial 또한 내가 생각한 거랑 똑같은 방법으로 접근하고 있었다. 한 10분만 더 고민했으면 풀 수 있었을 것 같았으나 곧 점호였고 고3이 시간을 너무 쓰는 것 같아서 포기를 합리화했다.   n = int(input()) ans = 0 mp = {}  for _ in range(n):     x, y = map(int, input().split())     while x % 2 == 0:         x //= 2         y *= 2     if x in mp:         mp[x] += y     else:         mp[x] = y  for value in mp.values():     while value &gt; 0:         if value % 2 == 1:             ans += 1         value //= 2  print(ans)  풀이 코드  그냥 처음에 입력받은 값에서 같은 크기의 녀석이 2개씩 짝지어질 수 있다면, 할 수 있는 한 전부 짝지어줘서 저장해 준다. 이후에, 저장된 녀석들을 다시 합쳐주면 된다. 사실 내가 떠올린 방법은 입력을 받을 때 반만 처리해서 다시 저장하는 방법이 아니라, 입력을 받을 때마다 모두 처리하는 방법이었는데 저장했다가 나중에 합쳐주는 Editorial의 방법이 구현이 더 쉬운 것 같다.  ","categories": ["PS"],
        "tags": ["Upsolving","3솔"],
        "url": "/PS/ABC323/",
        "teaser": null
      },{
        "title": "효정과 새 모니터",
        "excerpt":"   [Silver V] 효정과 새 모니터 - 20949    성능 요약   메모리: 109108 KB, 시간: 120 ms   분류   정렬   문제 설명   효정은 새해를 맞이하여 새 모니터를 구매하고자 한다. 효정은 돈이 많기 때문에 77인치 모니터를 구매할 것이다. 모니터를 구경하던 효정은 놀라 자빠질 수밖에 없었다. 모니터가 너무 많아 고를 수가 없었기 때문이다. 이왕이면 고해상도가 좋은 법, 효정은 PPI가 가장 높은 모니터를 구매할 것이다. 우선 효정은 PPI가 높은 순으로 모니터들을 정렬하기로 결심하였다.   PPI는 Pixels Per Inch의 약자로 인치당 몇 개의 픽셀이 존재하는지를 수치로 표현한 것이다. PPI는 다음과 같이 계산할 수 있다.    PPI=W2+H2D    여기서 W는 가로 픽셀 수, H는 세로 픽셀 수, D는 대각선의 길이(인치)이다. 예를 들어, Full HD 해상도는 가로 픽셀 수가 1920, 세로 픽셀 수가 1080이다. 따라서 24인치 Full HD 모니터의 PPI는 다음과 같다.    PPI=19202+1080224    N개의 모니터가 주어졌을 때, PPI가 높은 순으로 모니터들을 정렬하는 프로그램을 작성하시오. 모든 모니터의 크기는 77인치로 동일하다.   입력   첫 번째 줄에 모니터의 개수 N이 주어진다.   이후 N개의 줄 중 i(1 ≤ i ≤ N)번째 줄에는 i번 모니터의 가로 픽셀 수 Wi와 세로 픽셀 수 Hi가 주어진다.   모든 입력은 정수이며 공백으로 구분되어 주어진다.   출력   N개의 줄에 걸쳐 모니터의 번호를 PPI가 높은 순으로 한 줄에 하나씩 출력한다. PPI가 동일한 경우 번호가 더 작은 모니터를 먼저 출력한다.     풀이   문제 자체는 굉장히 간단했다. 그러나 PPI가 높은 순으로 한 줄에 하나씩 출력하고, PPI가 동일한 경우 번호가 더 작은 모니터를 먼저 출력하는 방법에 있어 정렬을 어떻게 해야 할지 몰랐다. 나는 문제를 dictionary를 이용해서 접근했기 때문에 key와 value를 각각 sort 하는 방법을 이용하려고 했다. 그러나 그 과정에서 어떻게 sort 해야 하는지 헷갈렸고 sort()의 key에 관해 조금 더 공부해 보았다.   import sys input = sys.stdin.readline from math import sqrt  n = int(input()) monitor = []  for i in range(1,n+1):     w,h = map(int,input().split())     monitor.append([i, sqrt(h**2+w**2)/77])  monitor.sort(key=lambda x: (-x[1], x[0]))  for i in monitor:     print(i[0])   기존에 dictionary를 sort 할 때는 key에 대해 sort 하거나 value에 대해 sort 하는 경우뿐이었는데 이렇게 key와 value를 모두 고려한 경우는 낯설었다. 그래도 이러한 경우는 많이 마주칠 것 같으니 꼭 알아둬야 할 필요가 있을 것 같다.  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/Algorithm/20949/",
        "teaser": null
      },{
        "title": "ABC329 풀이 및 후기",
        "excerpt":"   ABC329    [후기]      이번에도 3솔이다. 언제 4솔의 벽을 넘을 수 있을까. 이번 D는 특히 쉬웠는데 바보 같이 계속 $O(N^2)$ 풀이 방법에만 집중하다가 못풀었다. 조금 더 해볼 것 그랬다. 2시간 정도 진행되는 경우에 대략 1시간 정도만 하고 이후에 풀리는 문제가 없으면 드랍하고 답지가 나올 때까지 기다리는데, 솔직히 D번 문제는 드랍 안하고 더 고민했으면 풀지 않았을까 싶다. 이제부터라고 ABC가 진행되는 시간 동안에는 계속 풀려고 노력해봐야겠다.       처절한 TLE의 흔적들   [풀이]   A - Spread (0:45)      Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 100 points     Problem Statement  You are given a string S consisting of uppercase English letters. Separate each character of S with a space and print them one by one in order.     Constraints  S is a string consisting of uppercase English letters with a length between 2 and 100, inclusive.    간단하다. 주어진 문자열을 전부 띄어쓰면 된다.   import sys input = sys.stdin.readline  a = input() for i in a:     print(i, end=' ')  풀이 코드    B - Next (2:46)      Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 200 points     Problem Statement  You are given N integers $A_{1}​,A_{2},…,A_{N}$​. Find the largest among those integers that are not the largest. The constraints of this problem guarantee that the answer exists.     Constraints  2≤N≤100  1≤$A_{i}$≤100  It is not the case that all $A_{1}​,A_{2},…,A_{N}$ are equal.   All input values are integers.     주어진 숫자들 중에서 두번째로 큰 수를 찾으면 된다.   import sys input = sys.stdin.readline  n = int(input()) lst = sorted(list(map(int,input().split())), reverse=True)  for i in lst:     if i != max(lst):         print(i)         sys.exit(0)  어렵게 생각할 필요없이 list로 입력받아 내림차순 sort 해준 뒤, for로 하나씩 돌면서 숫자가 바뀌는 순간을 출력해주면 된다.  풀이 코드    C - Count xxx (16:33)     Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 250 points     Problem Statement  You are given a string S of length N consisting of lowercase English letters.     Find the number of non-empty substrings of S that are repetitions of one character. Here, two substrings that are equal as strings are not distinguished even if they are obtained differently.     A non-empty substring of S is a string of length at least one obtained by deleting zero or more characters from the beginning and zero or more characters from the end of S. For example, ab and abc are non-empty substrings of abc, while ac and the empty string are not.     Constraints  $2 ≤ N ≤ 2 \\times 10^5$  S is a string of length N consisting of lowercase English letters.    주어진 문자열 안에서 같은 알파벳이 반복되는 부분 수열을 몇 개 찾을 수 있냐는 문제이다. 예를 들어, aaabaa가 주어진 문자열이라면, 해당 문자열에서 찾을 수 있는 연속된 알파벳의 부분 수열은 a, aa, aaa, b가 있으므로 답은 4가 된다. 이 문제에서 유의할 점은 a 또는 aa와 같은 부분 수열을 찾는 방법이 여러가지라는 것이다. 언뜻보면 어떻게 풀어야하나 싶었는데, 곰곰히 생각해보면 주어진 문자열에서 특정 문자가 가장 길게 반복되는 부분을 모두 찾아 더하면 된다.   import sys input = sys.stdin.readline  n = int(input()) s = list(input().strip()) s.append(0)  if n == 1:     print(1)     sys.exit(0) else:     cnt = 1     dic = {}     for i in range(n):         if s[i] != s[i+1]:             if s[i] in list(dic.keys()):                 dic[s[i]] = max(cnt, dic[s[i]])             else:                 dic[s[i]] = cnt             cnt = 1         else:             cnt += 1  print(sum(list(dic.values())))  풀이 코드    Dictionary를 이용하였고, 초기값이 1로 지정된 cnt를 문자열을 앞에서부터 탐색해 나가며 한 iteration 당 cnt에 1을 계속 더해주다가 문자가 바뀌는 순간에 dictionary에 저장되어 있는 해당 문자의 값과 cnt 값을 비교해 더 큰 값으로 업데이트 해주었다. 그리고 마지막에는 dictionary value 값들을 모두 더해주었다.   [업솔빙]   D - Election Quick Report      Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 350 points     Problem Statement  There is an election to choose one winner from N candidates with candidate numbers $1,2,…,N$, and there have been M votes cast.     Each vote is for exactly one candidate, with the $i$-th vote being for candidate $A_{i}$​.     The votes will be counted in order from first to last, and after each vote is counted, the current winner will be updated and displayed.     The candidate with the most votes among those counted is the winner. If there are multiple candidates with the most votes, the one with the smallest candidate number is the winner.     For each $i=1,2,…,M$, determine the winner when counting only the first $i$ votes.     Constraints  $1≤N,M≤200000$  $1≤A_{i}​≤N$  All input values are integers.    해당 문제를 처음 봤을 때는 dictionary에 각 후보가 받은 표를 기록하고 이후에 max를 이용해가며 최다 득표자를 찾아나가고자 하였다. 그러나 계속 TLE가 떴고, 리스트를 사용하는 방법과, 처음부터 200000개의 리스트를 생성하는 것이 아닌 입력에 따라 차례대로 확장해내가는 방법도 써보았지만 전부 소용이 없었다.   이는 어느 부분에서 시간이 오래 걸리지는지 몰랐기 때문에 일어난 일이었다. 나의 풀이 방법은 매 순간 가장 득표 수가 많은 후보를 찾기 위해 비상수적인 시간의 탐색을 진행하였다. M회번 최대 N개의 값을 탐색해야하므로 나의 방법은 O(N*MlogM)의 시간복잡도로 바로 터져버리는 것이다. 따라서 상수적인 탐   n = int(input()) ans = 0 mp = {}  for _ in range(n):     x, y = map(int, input().split())     while x % 2 == 0:         x //= 2         y *= 2     if x in mp:         mp[x] += y     else:         mp[x] = y  for value in mp.values():     while value &gt; 0:         if value % 2 == 1:             ans += 1         value //= 2  print(ans)  풀이 코드  그냥 처음에 입력받은 값에서 같은 크기의 녀석이 2개씩 짝지어질 수 있다면, 할 수 있는 한 전부 짝지어줘서 저장해 준다. 이후에, 저장된 녀석들을 다시 합쳐주면 된다. 사실 내가 떠올린 방법은 입력을 받을 때 반만 처리해서 다시 저장하는 방법이 아니라, 입력을 받을 때마다 모두 처리하는 방법이었는데 저장했다가 나중에 합쳐주는 Editorial의 방법이 구현이 더 쉬운 것 같다.  ","categories": ["PS"],
        "tags": ["Upsolving","3솔"],
        "url": "/PS/ABC329/",
        "teaser": null
      },{
        "title": "C언어 입력없을 때까지 입력 받기",
        "excerpt":"   [Bronze V] A+B - 4 - 10951    문제 링크   성능 요약   메모리: 1112 KB, 시간: 0 ms   분류   구현, 사칙연산, 수학   제출 일자   2024년 1월 16일 17:07:58   문제 설명   두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.   입력   입력은 여러 개의 테스트 케이스로 이루어져 있다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   출력   각 테스트 케이스마다 A+B를 출력한다.     풀이   프로그래밍을 처음 배웠을 때부터 Python만을 써왔고, 모든 PS와 프로젝트들 또한 Python만으로 해결해 왔다. 그 정도로 다른 언어는 쳐다볼 생각도 하지 않았지만, 대학교 수업이 C언어로 진행된다면 말이 달라진다. 어쩔 수 없이 고등학교 시절 프로그래밍 시간을 위해 조금 공부한 C언어를 기억에서 끄집어내 다시 공부하기로 하였다. C언어를 책이나 영상으로 다시 공부하다가는 금방 질려버릴 것이 뻔했기에, 가장 먼저 C언어로 백준 새싹 문제부터 다시 풀기로 했다.   그렇게 문제들을 풀어나가면서 C언어의 scanf, 논리 연산자, 자료형 등에 관해 공부해 나가던 중 해당 문제가 발목을 잡게 되었다. 처음 파이썬을 공부할 때도 입력 종료 조건이 없을 때 어떻게 반복해서 입력받는지 몰라 try execpt 구문을 이용해 풀어낸 적이 있었다. 그러나 배경지식도 없는 C에서는 이를 어떻게 해결해야 할지 몰라 끙끙댔다.   #include &lt;stdio.h&gt; int main(){     int a,b;     while (scanf(\"%d %d\", &amp;a,&amp;b) != EOF)     {         printf(\"%d\\n\", a+b);     } }   방법은 EOF 에러가 발생하는지 확인하는 조건으로 While 문을 돌리는 것이었다.   EOF란 End Of File의 약자이며, 말 그대로 파일의 끝을 표현하기 위한 상수(-1)이다. C언어는 운영체제에 상관없이 파일의 끝에 도달했을 때 언제나 특별한 값인 EOF를 반환하게 되어있기에 이를 사용하면 입력 종료 조건이 없을 때도 While 문을 이용해 입력받을 수 있다. EOF는 또한 대부분의 UNIX 시스템에서는 Ctrl+D, 윈도우 시스템에서는 Ctrl+Z Enter를 통해 강제적으로 발생시킬 수 있다는 것을 배웠다.  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/Algorithm/10951/",
        "teaser": null
      },{
        "title": "HCU telegram 1편",
        "excerpt":"HCU telegrambot   꽤 오랜만에 블로그에 글을 쓴다. 사실 귀찮았던 것도 있지만, 고등학교 졸업 이후에 여기저기 놀러 다니고 게임을 하느라 프로그래밍 공부 자체를 느슨하게 한 것이 가장 크다…   어찌 되었건 이제 이틀 뒤면 대학교 입학이고, 때마침 전산동아리 WING이 모집 공고를 올렸기에 이를 계기로 HCU telegrambot의 개발 스토리를 조금 정리해보자고 한다. 사실 실질적인 개발 기간은 약 1년 정도밖에 걸리지 않았지만, 그 과정을 이해하고 공부해 나가는 데에는 3년이라는 고등학교 생활 전체에 달하는 시간이 들었다.   SQL을 제외한다면 오로지 Python만으로 만들어진 해당 프로젝트는 사실 다른 언어와 함께 사용(예를 들어 서버와 통신하는 쪽)했으면 훨씬 가볍고 빠를 수 있었겠지만, 그럼에도 개인적으로는 성공했다고 생각하는 프로젝트이며 꽤나 의미 있는 교훈을 많이 얻었다.   청운 네트워크   청운고는 생각보다 많은 학교 내의 행정적인 업무가 청운네트워크로 처리되고 있었으며, 1학년 갓 입학한 나에게는 청운네트워크는 재미있는 놀이터였다. 입학 1주일 만에 청운 네트워크를 해킹해 내면서 친구들의 청운네트워크 계정을 탈취할 수 있었고, 얼마 안 가서 특정 선생님들의 계정 또한 해킹했다. 확실히 지금 생각하면 정말 미친 짓이지만, 당시에는 정말 아무렇지도 않게 일을 벌인 것 같다. 덕분에 얼마 안가 선생님들의 블랙리스트에 들었고, 청운네트워크를 해킹해서 악용하지 않으리라 다짐하였다. 이후 혼자서 여러 프로젝트를 진행하면서 보안이 얼마나 힘든 분야인지도 깨닫게 되었고, 말에는 청운 네트워크의 보안 취약점을 분석하여 선생님들께 보고서도 제출했다. 하지만 이건 다른 이야기고 원래 이야기로 돌아와서, 나는 청운네트워크를 해킹하고 뜯어보면서 청운네트워크의 동작 방식에 관해 꽤 많은 것을 배우게 되었다. 그리고 이를 이해하기 위해 계속해서 공부를 거듭한 결과, 웹이 어떻게 동작하는지, 그리고 서버와 어떻게 통신하는지, 이를 크롤링을 통해서 어떻게 메크로로 만들 수 있는지를 부수적으로 배우게 됐다. 사실 웹은 딱히 내가 크게 관심을 가지는 분야가 아니었기에, 각각에 관해 깊게 공부하지는 않았지만 그래도 나름 어떻게 하면 직접 사이트에 접속하지 않고 서버와 통신하며 정보를 주고받을 수 있는지 정도는 아는 수준에 다다랐다.   급식 단축어   HCU telegrambot과 급식 단축어가 무슨 상관이냐고 하는 사람들도 있겠느냐마는, 사실 급식 단축어를 통해 크롤링의 기본적인 원리를 배웠다고 해도 과언이 아니다. 웹사이트의 구조를 파악하여 원하는 정보를 어떻게 가져오는지, 그리고 정규표현식을 이용하여 원하는 페턴의 정보를 가져오는 일은 사실 전혀 어려운 것은 아니었다. 그래도 급식 단축어가 성공하면서 나에게 HCU telegrambot을 개발할 아이디어가 떠올랐고, 1학년 2학기 때부터 HCU telegrambot을 계획하게 되었다.   로그인, 그리고 고난   사실 HCU telegrambot을 만들면서 무엇이 가장 힘들었냐고 묻는다면 나는 로그인 문제 해결과 보안 문제라고 답할 것이다. 보안 문제는 말 그대로 어떻게 하면 해당 프로젝트의 보안성을 향상할 수 있을까의 문제였고, 로그인 문제는 어떻게 하면 telegram과 청운네트워크를 직접적으로 연동하고, 이를 통해서 청운네트워크에 로그인하냐는 문제였다. 이거 알아내는 데만 1년 걸렸다(사실 도중부터는 거의 포기해서 1년이지 실은 한 3달 걸렸다). 기존에 Python을 통해서 사이트에 로그인하는 방법은 쿠키를 이용해서 사이트에 접속하는 방법이었는데, 이는 서버가 동시에 여러 계정을 관리하게 되면 쿠키끼리 겹쳐서 A의 계정과 B의 계정 정보가 뒤죽박죽되는 문제가 일어났다. 그래서 하는 수 없이 post에 관해 공부하며 python의 requests 라이브러리를 이용해 사이트에 로그인하였다. 아래는 내가 실제로 사용한 코드이다.   with requests.Session() as s:   data = {       'sel': 'stu',       'text1': student_num,       'password': pw,   }   s.post('https://hcuhs.kr/login_check.php', headers=headers, data=data)   response = s.get(url=url, headers=headers)   response.encoding = 'EUC-KR'   if response.status_code == 200:       if '접속이 끊어졌습니다' not in response.text:           return response.text   참고로 headers는 그냥 아무거나 사용해도 되며,url은 로그인 이후 접속하고 싶은 페이지를 입력하면 된다. 예를 들면 급식신청 페이지라면, “https://hcuhs.kr/meal/student.php”을 url로 넣으면 된다. 이렇게 오랜 숙원 중 하나였던 “청운네트워크에 로그인해 정보 가져오기”를 해결하였다.   SQL 서버   청운네트워크에 로그인해서 정보를 가져오는 데에는 성공하였지만, 많은 계정을 저장해서 관리하는 것은 또 다른 문제였다. 이를 해결하기 위해 SQL 서버를 도입하기로 하였고, 서버와 백엔드에 관해 공부하기 시작했다. 기본적인 SQL 서버의 구조는 telegram이 가지는 유저의 개인 고유 id를 key값으로 하였으며, 유저의 학번과 자동 급식 신청 여부(후에 더 자세하게 다루겠다) 등 여러 정보를 저장하는 데 유용하게 사용되었다. 그리고 HCU telegrambot은 Python을 백엔드로 사용하기에 pymysql을 통해 SQL 서버와 통신하게 했다.     로그인 이후 HCU telegramnbot이 작동하는 원리는 속편에서 더욱 자세하게 설명하겠다.  ","categories": ["Dev","HCU telegrambot"],
        "tags": ["Python","1인 개발"],
        "url": "/categories1/HCU%20telegram/",
        "teaser": null
      }]
