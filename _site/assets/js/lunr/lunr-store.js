var store = [{
        "title": "ABC323 풀이 및 후기",
        "excerpt":"   ABC323    [후기]     영광스러운 블로그의 첫 게시물이다. 고3이 수능이 40일도 남지 않은 시점에서 블로그를 만들고 Atcoder에 참가하고 후기까지 쓰고 있다. 최대한 자제하고는 싶었지만, 오늘 친 실모가 점수가 잘 떴다는 변명 하나로 합리화하면서 좀 놀았다.   Atcoder에 참가한 경험이 많지는 않지만, Atcoder problems를 심심할 때마다 풀어본 경험으로 미루어 보았을 때, 전체적으로 쉬웠던 편이라고 느꼈다.   사실, 다른 문제들에 비해 쉽다고 느꼈을 뿐이지 그렇다고 해서 드라마틱하게 많이 풀거나 그러진 못했다.      A, B를 10분 안에 풀어서 이때까지만 해도 느낌이 좋았지만, C에서 wrong이 떠서 30분 넘게 시간을 허비하면서 D는 볼 힘도 남아있지 않았었다.    D는 대회 이후 업솔빙 했다.   [풀이]   A - Weak Beats (2:14)      Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 100 points     Problem Statement  You are given a string S of length 16 consisting of 0 and 1. If the i-th character of S is 0 for every even number i from 2 through 16, print Yes; otherwise, print No.     Constraints  (S is a string of length 16 consisting of 0 and 1.)    0과 1로 이루어진 16자리의 문자열이 주어진다. 이때, 짝수 번째에 위치한 숫자가 모두 0이면 Yes을 출력, 아니면 No을 출력하는 문제다.   import sys input = sys.stdin.readline  num = input()  for i in range(1,17):     if i%2 == 0:         if num[i-1] == '1':             print('No')             sys.exit(0)  print('Yes')  풀이 코드  사실 엄청 쉬운 문제인데 영어라서 시간이 걸렸다. 영어 속독 연습해야 할 듯…   B - Round-Robin Tournament (6:54)      Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 200 points     Problem Statement  There are N players numbered 1 to N, who have played a round-robin tournament. For every match in this tournament, one player won and the other lost. The results of the matches are given as N strings $S_{1}​,S_{2}​,…,S_{N}​$ of length N each, in the following format:                 If i != j, the j-th character of $S_{i}$ is o or x. o means that player i won against player j, and x means that player i lost to player j.                  If i=j, the j-th character of $S_{i}$​ is -.             The player with more wins ranks higher. If two players have the same number of wins, the player with the smaller player number ranks higher. Report the player numbers of the N players in descending order of rank.     Constraints  2≤N≤100  N is an integer.  Si​ is a string of length  N consisting of o, x, and -.  $S_{1}​,…,S_{N}$​ conform to the format described in the problem statement.    o 의 개수를 점수로 생각하고, 점수와 동시에 N을 저장한다. 이후, N에 대해서 오름차순으로 정리하고, 점수에 대해 내림차순으로 정렬한다.   import sys input = sys.stdin.readline  n = int(input()) lst = [] ans = []  for _ in range(n):     lst.append((input().count('o'), _+1))  lst.sort(key=lambda x:x[1]) lst.sort(key=lambda x:x[0], reverse=True)  for _, i in lst:     print(i, end=' ')  풀이 코드  sort를 어떻게 해야 할지 까먹었었다. sort()의 key를 사용해서 특정 부분에 따라 정렬할 수 있다.   C - World Tour Finals (41:31)     Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 250 points     Problem Statement  The programming contest World Tour Finals is underway, where N players are participating, and half of the competition time has passed. There are M problems in this contest, and the score $A_{i}$​ of problem i is a multiple of 100 between 500 and 2500, inclusive.     For each i=1,…,N, you are given a string Si​ that indicates which problems player i has already solved. $S_{i}$​ is a string of length M consisting of o and x, where the j-th character of Si​ is o if player i has already solved problem j, and x if they have not yet solved it. Here, none of the players have solved all the problems yet.     The total score of player i is calculated as the sum of the scores of the problems they have solved, plus a bonus score of i points.     For each i=1,…,N, answer the following question.          At least how many of the problems that player i has not yet solved must player i solve to exceed all other players’ current total scores?       Note that under the conditions in this statement and the constraints, it can be proved that player i can exceed all other players’ current total scores by solving all the problems, so the answer is always defined.     Constraints  2≤N≤100  1≤M≤100  500≤$A_{i}$​≤2500  $A_{i}$​ is a multiple of 100.  $S_{i}$​ is a string of length  M consisting of o and x.  $S_{i}$​ contains at least one x.  All numeric values in the input are integers.    문제 한번 더럽게 길다. 솔직히 30분 중에 이해하는데 10분 넘게 쓴 거 같다. 게다가 처음 넣은 답은 접근 자체는 맞았지만 ‘이미 푼 문제’를 고려하지 않아서 틀려버렸다. 이거 생각해 내는데 꽤 걸렸었다. 이후 ‘풀지 않은 문제들(풀 수 있는 문제들)’을 none_solve 리스트에 저장해서 해결했다.   import sys from collections import deque input = sys.stdin.readline  n,m = map(int,input().split()) score = list(map(int,input().split())) current = [] part_score = [] none_solve = list([] for x in range(n))   for _ in range(n):     current.append(list(input().strip()))  for i in range(n):     a = 0     for j in range(m):         if current[i][j] == 'o':             a += score[j]         else:             none_solve[i].append(score[j])     part_score.append(a+i+1)  for i in range(n):     a = part_score[i]     ans = 0     while a &lt; max(part_score):         a += sorted(none_solve[i], reverse=True)[ans]         ans += 1     print(ans)  풀이 코드  제출한 오답  고작 이 정도 구현으로 힘들어하다니 백준 실랜디 좀 열심히 해야 할 것 같다.   [업솔빙]   D - Merge Slimes      Time Limit: 3 sec / Memory Limit: 1024 MB  Score :425 points     Problem Statement  Initially, there are N sizes of slimes. Specifically, for each 1≤i≤N, there are $C_{i}$​ slimes of size $S_{i}$​.     Takahashi can repeat slime synthesis any number of times (possibly zero) in any order. Slime synthesis is performed as follows.          Choose two slimes of the same size. Let this size be X, and a new slime of size 2X appears. Then, the two original slimes disappear.       Takahashi wants to minimize the number of slimes. What is the minimum number of slimes he can end up with by an optimal sequence of syntheses?     Constraints  $1≤N≤10^{5}$  $1≤S_{i}​≤10^9$  $1≤C_{i}​≤10^9$  $S_{1}​,S_{2}​,…,S_{N}$​ are all different.  All input values are integers.    문제를 보고 바로 생각난 것은 2048 game이었다. 그다음으로 생각난 건 ‘도대체 어떻게 풀지’였다.   처음에는 주어진 횟수만큼 반복을 돌아서 모든 슬라임들이 존재하는 리스트를 만들고, 이후에 차례대로 슬라임을 합쳐주는 함수를 정의해서 재귀적으로 해결하려고 하였다. 그러나 $S_{i}$와 $C_{i}$ 가 각각 $10^9$까지 가능하였기에 입력에서만 $O(n^{2})$의 복잡도를 가지는 해당 방법은 사용할 수가 없었다. 그래서 시간을 봤는데, 3초 시간제한에 메모리는 1024 MB이길레 사실 이때 그냥 포기하고 GIST 면접 준비했다. 대회가 끝난 이후, 다시 문제를 보면서 mod(%) 연산과 Floor division(//) 연산을 사용해서 어떻게 줄일 수 있지 않을까 싶었는데, 더 생각하기 귀찮아져서 바로 Editorial을 깠다.   그런데 Editorial 또한 내가 생각한 거랑 똑같은 방법으로 접근하고 있었다. 한 10분만 더 고민했으면 풀 수 있었을 것 같았으나 곧 점호였고 고3이 시간을 너무 쓰는 것 같아서 포기를 합리화했다.   n = int(input()) ans = 0 mp = {}  for _ in range(n):     x, y = map(int, input().split())     while x % 2 == 0:         x //= 2         y *= 2     if x in mp:         mp[x] += y     else:         mp[x] = y  for value in mp.values():     while value &gt; 0:         if value % 2 == 1:             ans += 1         value //= 2  print(ans)  풀이 코드  그냥 처음에 입력받은 값에서 같은 크기의 녀석이 2개씩 짝지어질 수 있다면, 할 수 있는 한 전부 짝지어줘서 저장해 준다. 이후에, 저장된 녀석들을 다시 합쳐주면 된다. 사실 내가 떠올린 방법은 입력을 받을 때 반만 처리해서 다시 저장하는 방법이 아니라, 입력을 받을 때마다 모두 처리하는 방법이었는데 저장했다가 나중에 합쳐주는 Editorial의 방법이 구현이 더 쉬운 것 같다.  ","categories": ["PS"],
        "tags": ["Upsolving","3솔"],
        "url": "/PS/ABC323/",
        "teaser": null
      },{
        "title": "효정과 새 모니터",
        "excerpt":"   [Silver V] 효정과 새 모니터 - 20949    성능 요약   메모리: 109108 KB, 시간: 120 ms   분류   정렬   문제 설명   효정은 새해를 맞이하여 새 모니터를 구매하고자 한다. 효정은 돈이 많기 때문에 77인치 모니터를 구매할 것이다. 모니터를 구경하던 효정은 놀라 자빠질 수밖에 없었다. 모니터가 너무 많아 고를 수가 없었기 때문이다. 이왕이면 고해상도가 좋은 법, 효정은 PPI가 가장 높은 모니터를 구매할 것이다. 우선 효정은 PPI가 높은 순으로 모니터들을 정렬하기로 결심하였다.   PPI는 Pixels Per Inch의 약자로 인치당 몇 개의 픽셀이 존재하는지를 수치로 표현한 것이다. PPI는 다음과 같이 계산할 수 있다.    PPI=W2+H2D    여기서 W는 가로 픽셀 수, H는 세로 픽셀 수, D는 대각선의 길이(인치)이다. 예를 들어, Full HD 해상도는 가로 픽셀 수가 1920, 세로 픽셀 수가 1080이다. 따라서 24인치 Full HD 모니터의 PPI는 다음과 같다.    PPI=19202+1080224    N개의 모니터가 주어졌을 때, PPI가 높은 순으로 모니터들을 정렬하는 프로그램을 작성하시오. 모든 모니터의 크기는 77인치로 동일하다.   입력   첫 번째 줄에 모니터의 개수 N이 주어진다.   이후 N개의 줄 중 i(1 ≤ i ≤ N)번째 줄에는 i번 모니터의 가로 픽셀 수 Wi와 세로 픽셀 수 Hi가 주어진다.   모든 입력은 정수이며 공백으로 구분되어 주어진다.   출력   N개의 줄에 걸쳐 모니터의 번호를 PPI가 높은 순으로 한 줄에 하나씩 출력한다. PPI가 동일한 경우 번호가 더 작은 모니터를 먼저 출력한다.     풀이   문제 자체는 굉장히 간단했다. 그러나 PPI가 높은 순으로 한 줄에 하나씩 출력하고, PPI가 동일한 경우 번호가 더 작은 모니터를 먼저 출력하는 방법에 있어 정렬을 어떻게 해야 할지 몰랐다. 나는 문제를 dictionary를 이용해서 접근했기 때문에 key와 value를 각각 sort 하는 방법을 이용하려고 했다. 그러나 그 과정에서 어떻게 sort 해야 하는지 헷갈렸고 sort()의 key에 관해 조금 더 공부해 보았다.   import sys input = sys.stdin.readline from math import sqrt  n = int(input()) monitor = []  for i in range(1,n+1):     w,h = map(int,input().split())     monitor.append([i, sqrt(h**2+w**2)/77])  monitor.sort(key=lambda x: (-x[1], x[0]))  for i in monitor:     print(i[0])   기존에 dictionary를 sort 할 때는 key에 대해 sort 하거나 value에 대해 sort 하는 경우뿐이었는데 이렇게 key와 value를 모두 고려한 경우는 낯설었다. 그래도 이러한 경우는 많이 마주칠 것 같으니 꼭 알아둬야 할 필요가 있을 것 같다.  ","categories": ["Algorithm"],
        "tags": [],
        "url": "/Algorithm/20949/",
        "teaser": null
      },{
        "title": "ABC329 풀이 및 후기",
        "excerpt":"   ABC329    [후기]      이번에도 3솔이다. 언제 4솔의 벽을 넘을 수 있을까. 이번 D는 특히 쉬웠는데 바보 같이 계속 $O(N^2)$ 풀이 방법에만 집중하다가 못풀었다. 조금 더 해볼 것 그랬다. 2시간 정도 진행되는 경우에 대략 1시간 정도만 하고 이후에 풀리는 문제가 없으면 드랍하고 답지가 나올 때까지 기다리는데, 솔직히 D번 문제는 드랍 안하고 더 고민했으면 풀지 않았을까 싶다. 이제부터라고 ABC가 진행되는 시간 동안에는 계속 풀려고 노력해봐야겠다.       처절한 TLE의 흔적들   [풀이]   A - Spread (0:45)      Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 100 points     Problem Statement  You are given a string S consisting of uppercase English letters. Separate each character of S with a space and print them one by one in order.     Constraints  S is a string consisting of uppercase English letters with a length between 2 and 100, inclusive.    간단하다. 주어진 문자열을 전부 띄어쓰면 된다.   import sys input = sys.stdin.readline  a = input() for i in a:     print(i, end=' ')  풀이 코드    B - Next (2:46)      Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 200 points     Problem Statement  You are given N integers $A_{1}​,A_{2},…,A_{N}$​. Find the largest among those integers that are not the largest. The constraints of this problem guarantee that the answer exists.     Constraints  2≤N≤100  1≤$A_{i}$≤100  It is not the case that all $A_{1}​,A_{2},…,A_{N}$ are equal.   All input values are integers.     주어진 숫자들 중에서 두번째로 큰 수를 찾으면 된다.   import sys input = sys.stdin.readline  n = int(input()) lst = sorted(list(map(int,input().split())), reverse=True)  for i in lst:     if i != max(lst):         print(i)         sys.exit(0)  어렵게 생각할 필요없이 list로 입력받아 내림차순 sort 해준 뒤, for로 하나씩 돌면서 숫자가 바뀌는 순간을 출력해주면 된다.  풀이 코드    C - Count xxx (16:33)     Time Limit: 2 sec / Memory Limit: 1024 MB  Score : 250 points     Problem Statement  You are given a string S of length N consisting of lowercase English letters.     Find the number of non-empty substrings of S that are repetitions of one character. Here, two substrings that are equal as strings are not distinguished even if they are obtained differently.     A non-empty substring of S is a string of length at least one obtained by deleting zero or more characters from the beginning and zero or more characters from the end of S. For example, ab and abc are non-empty substrings of abc, while ac and the empty string are not.     Constraints  $2 ≤ N ≤ 2 \\times 10^5$  S is a string of length N consisting of lowercase English letters.    주어진 문자열 안에서 같은 알파벳이 반복되는 부분 수열을 몇 개 찾을 수 있냐는 문제이다. 예를 들어, aaabaa가 주어진 문자열이라면, 해당 문자열에서 찾을 수 있는 연속된 알파벳의 부분 수열은 a, aa, aaa, b가 있으므로 답은 4가 된다. 이 문제에서 유의할 점은 a 또는 aa와 같은 부분 수열을 찾는 방법이 여러가지라는 것이다. 언뜻보면 어떻게 풀어야하나 싶었는데, 곰곰히 생각해보면 주어진 문자열에서 특정 문자가 가장 길게 반복되는 부분을 모두 찾아 더하면 된다.   import sys input = sys.stdin.readline  n = int(input()) s = list(input().strip()) s.append(0)  if n == 1:     print(1)     sys.exit(0) else:     cnt = 1     dic = {}     for i in range(n):         if s[i] != s[i+1]:             if s[i] in list(dic.keys()):                 dic[s[i]] = max(cnt, dic[s[i]])             else:                 dic[s[i]] = cnt             cnt = 1         else:             cnt += 1  print(sum(list(dic.values())))  풀이 코드    Dictionary를 이용하였고, 초기값이 1로 지정된 cnt를 문자열을 앞에서부터 탐색해 나가며 한 iteration 당 cnt에 1을 계속 더해주다가 문자가 바뀌는 순간에 dictionary에 저장되어 있는 해당 문자의 값과 cnt 값을 비교해 더 큰 값으로 업데이트 해주었다. 그리고 마지막에는 dictionary value 값들을 모두 더해주었다.   [업솔빙]   D - Election Quick Report      Time Limit: 3 sec / Memory Limit: 1024 MB  Score :425 points     Problem Statement  There is an election to choose one winner from N candidates with candidate numbers $1,2,…,N$, and there have been M votes cast.     Each vote is for exactly one candidate, with the $i$-th vote being for candidate $A_{i}$​.     The votes will be counted in order from first to last, and after each vote is counted, the current winner will be updated and displayed.     The candidate with the most votes among those counted is the winner. If there are multiple candidates with the most votes, the one with the smallest candidate number is the winner.     For each $i=1,2,…,M$, determine the winner when counting only the first $i$ votes.     Constraints  $1≤N,M≤200000$  $1≤A_{i}​≤N$  All input values are integers.    해당 문제를 처음 봤을 때는 dictionary를 이용해 각 후보가   n = int(input()) ans = 0 mp = {}  for _ in range(n):     x, y = map(int, input().split())     while x % 2 == 0:         x //= 2         y *= 2     if x in mp:         mp[x] += y     else:         mp[x] = y  for value in mp.values():     while value &gt; 0:         if value % 2 == 1:             ans += 1         value //= 2  print(ans)  풀이 코드  그냥 처음에 입력받은 값에서 같은 크기의 녀석이 2개씩 짝지어질 수 있다면, 할 수 있는 한 전부 짝지어줘서 저장해 준다. 이후에, 저장된 녀석들을 다시 합쳐주면 된다. 사실 내가 떠올린 방법은 입력을 받을 때 반만 처리해서 다시 저장하는 방법이 아니라, 입력을 받을 때마다 모두 처리하는 방법이었는데 저장했다가 나중에 합쳐주는 Editorial의 방법이 구현이 더 쉬운 것 같다.  ","categories": ["PS"],
        "tags": ["Upsolving","3솔"],
        "url": "/PS/ABC329/",
        "teaser": null
      }]
